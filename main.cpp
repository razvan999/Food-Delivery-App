#include<iostream>

// #include<chrono>

// using namespace std;

// int main() {

//     auto start = chrono::high_resolution_clock::now();

//     cout << "Hello World" << endl;


//     auto end = chrono::high_resolution_clock::now();
//     chrono::duration<double> duration = end - start;
//     cout << "Time taken: " << duration.count() << " seconds" << std::endl;

//     return 0;
// }





// cred ca o sa folosesc nearest neighbor
// sau algoritmul lui prim


// oare e mai bine sa fac tsp pe tot graful si dupa sa iau in calcul curierii???

/*

Cluster-First, Route-Second (CFRS) Approach: In this approach, 
the problem is first divided into clusters of customers, and then a minimum spanning tree (or a similar method)
 is used to connect the clusters. Once the clusters are connected, traditional methods such as nearest neighbor,
  genetic algorithms, or simulated annealing can be applied to find the optimal routes within each cluster.

*/

int main() {
    std::cout << "Hello World" << std::endl;
    return 0;
}